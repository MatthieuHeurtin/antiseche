///////////////////dans le .h//////////////////
#include <stdio.h>
#define M 25
struct wesh
{
	char nom[M];
	char grade[M];
};
//que les prototypes
typedef struct wesh wesh;

//////////main.c////////////////////////////
#include <stdio.h>
#include <string.h>
#include "fonction.h"
int main(int argc, char **argv)
{

	 wesh joueur1;
	printf("C'est quoi ton nom\n");
	scanf("%s", joueur1.nom);
	printf("ton nom est %s\n", joueur1.nom);
	printf("Quel est ton grade?\n");
	scanf("%s", joueur1.grade);
	strcat(joueur1.nom, joueur1.grade);
	printf("Salut à toi %s ", joueur1.nom);
	
	return 0;
}


///////////lire un fichier//////////////////
int main(int argc, char *argv[])
{
    FILE* fichier = NULL;
    int score[3] = {0}; // Tableau des 3 meilleurs scores
 
    fichier = fopen("test.txt", "r");
 
    if (fichier != NULL)
    {
        fscanf(fichier, "%d %d %d", &score[0], &score[1], &score[2]);
        printf("Les meilleurs scores sont : %d, %d et %d", score[0], score[1], score[2]);
 
        fclose(fichier);
    }
 
    return 0;
}
//////////////ecrire dans un fichier//////////
int main(int argc, char *argv[])
{
    FILE* fichier = NULL;
    int age = 0;
 
    fichier = fopen("test.txt", "w");
 
    if (fichier != NULL)
    {
        // On demande l'âge
        printf("Quel age avez-vous ? ");
        scanf("%d", &age);
 
        // On l'écrit dans le fichier
        fprintf(fichier, "Le Monsieur qui utilise le programme, il a %d ans", age);
        fclose(fichier);
    }
 
    return 0;
}
/////////////////////////Memoire allocation/////////////////
int main(int argc, char *argv[])
{
    int* memoireAllouee = NULL;

    memoireAllouee = malloc(sizeof(int)); // Allocation de la mémoire
    if (memoireAllouee == NULL)
    {
        exit(0);
    }

    // Utilisation de la mémoire
    printf("Quel age avez-vous ? ");
    scanf("%d", memoireAllouee);
    printf("Vous avez %d ans\n", *memoireAllouee);

    free(memoireAllouee); // Libération de mémoire

    return 0;
}
///////////////////////allocation d'un tableau////////////////////////////////////////
int main(int argc, char *argv[])
{
    int* memoireAllouee = NULL;
//memoireAllouee est le pointeur qui pointe vers la première case du tableau
    memoireAllouee = malloc(4 * sizeof(int));
    if (memoireAllouee == NULL) // Si l'allocation a échoué
    {
        exit(0); // On arrête immédiatement le programme
    }

    // On peut continuer le programme normalement sinon

  // On peut utiliser ici la mémoire
    free(memoireAllouee); // On n'a plus besoin de la mémoire, on la libère

    return 0;
}


///////////////////////////////////////////deplacement curseur///////////////////////
int fseek(FILE* pointeurSurFichier, long deplacement, int origine);

fseek(fichier, 0, SEEK_END);


    SEEK_SET : indique le début du fichier.
    SEEK_CUR : indique la position actuelle du curseur.
    SEEK_END : indique la fin du fichier.

/////////////////////////pointeur////////////////////
    Sur une variable, comme la variable age :
        "age" signifie : "Je veux la valeur de la variable age".
        "&age" signifie : "Je veux l'adresse où se trouve la variable age".
    Sur un pointeur, comme pointeurSurAge :
        "pointeurSurAge" signifie : "Je veux la valeur de pointeurSurAge" (cette valeur étant une adresse).
        "*pointeurSurAge" signifie : "Je veux la valeur de la variable qui se trouve à l'adresse contenue dans pointeurSurAge"


/////////////////////renvoie la position du curseur///////////////
long ftell(FILE* pointeurSurFichier);

/////////////////////////////sauter une ligne dans un dossier////////
while(fgetc(graphe) != '\n');

////////////////////////les listes/////////////////////////////////////////////// 
#include <stdlib.h>
 
typedef struct element element;
struct element
{
    int val;
    struct element *nxt;
};
 
typedef element* llist;
 
 
 
int main(int argc, char **argv)
{
    /* Déclarons 3 listes chaînées de façons différentes mais équivalentes */
    llist ma_liste1 = NULL;
    element *ma_liste2 = NULL;
    struct element *ma_liste3 = NULL;
 
 
    return 0;
}

////////////////////make file (SDL aussi)///////////////////////////////
CFLAGS=-W -Wall -ansi -pedantic

All : main.o fonction.o
	gcc main.o fonction.o -o l  `sdl-config --cflags --libs` $(LDFLAGS)
 
main.o : main.c fonction.c
	gcc -c main.c -o main.o $(LDFLAGS)
 
fonction.o : fonction.c
	gcc -c fonction.c -o fonction.o $(LDFLAGS)


clean:
	rm -rf *.o

mrproper: clean
	rm -rf l


///////////////////////////FREAD//////////////
Comme vous le voyez, cette fonction va renvoyer une variable de type size_t qui est en fait une valeur entière contenant le nombre d'éléments que la fonction aura lu. En ce qui concerne les arguments, vous voyez que cette fonction en prend 4 et ceux-ci sont les même que pour la fonction fwrite. Le premier déterminera dans quelle variable les données lues seront stockées, le deuxième désigne la taille des données qui seront lues, le troisième définit le nombre de fois que nous lirons cette taille et le dernier paramètre est le pointeur de fichier dans lequel la lecture s'effectuera.

    size_t fread (void *ptr, size_t size, size_t nmemb, FILE *stream);  



/////////////////////////////STRCMP//////////////////////////
strcmp(ligne,"P5") !=0)					/*strcmp renvoie 0 si ligne == P5, là ça va comparer ce qu'il y a dans le tableau "lign" et "P5" */


/////////////////EOF= fin de fichier/////////////


////////////////////////FWRITE//////////////////////////////////////////////
size_t fwrite (const void *ptr, size_t size, size_t nmemb, FILE *stream);



    ptr pointeur sur le premier octet de la liste d'objets à inscrire.
    size L'espace mémoire pris par un membre de la liste d'objets à inscrire.
    nmemb Le nombre de membres ayant la taille size dans la liste d'objets à inscrire.
    stream Pointeur sur le flux (pointeur sur FILE dans notre cas).
    Valeur retournée La fonction fwrite retourne le nombre d'éléments qu'elle a réussi à inscrire correctement dans le flux pointé par stream.

////////////////////////fget////////////////////////////////
fgets(ligne, 1024, fichier_image)

ligne : chaine de caractère
1024, nbr de cara qu'il doit lire
fichier_image: nom du fichier
elle renvoie NULL quand elle n'a plus rien à lire. (NON EOF)


//////chaine de caractère info/////////////////////////////////////////////

pour afficher une chaine 
printf("%s", chaine);

pour afficher un seul caractère
printf("%c", chaine[2]);

pour son code ascii
printf("%d", chaine[2]);












